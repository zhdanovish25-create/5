#include <Arduino_FreeRTOS.h>
#include <queue.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ThreeWire.h>
#include <RtcDS1302.h>
#include <Keypad.h>
#include <EEPROM.h>

// ==================== КОНФИГУРАЦИЯ ====================
// Глобальные хэндлы
QueueHandle_t xLuxQueue;
QueueHandle_t xLogQueue;

// Дисплей
LiquidCrystal_I2C lcd(0x27, 16, 2);

// RTC
ThreeWire myWire(4, 5, 2); // DAT, CLK, RST
RtcDS1302<ThreeWire> Rtc(myWire);

// Клавиатура 4x4
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {6, 7, 8, 9};
byte colPins[COLS] = {10, 11, 12, 13};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// Пин фоторезистора
const int photoPin = A0;

// ==================== СТРУКТУРЫ ДАННЫХ ====================
struct CalibrationPoint {
    int adc;
    float lux;
};

struct LogEntry {
    float lux;
    uint32_t timestamp;
    char label[21]; // 20 символов + null
};

// Калибровочные данные
const CalibrationPoint CalibrationData[] = {
    {200, 10.0}, {400, 150.0}, {500, 300.0}, {600, 500.0},
    {700, 750.0}, {800, 1000.0}, {850, 1200.0}, {900, 1300.0},
    {950, 1400.0}, {1000, 1500.0}
};
const int CalibrationSize = sizeof(CalibrationData) / sizeof(CalibrationPoint);

// ==================== ПРОТОТИПЫ ФУНКЦИЙ ====================
void vTaskMeasureLuminosity(void *pvParameters);
void vTaskDisplay(void *pvParameters);
void vTaskRTC(void *pvParameters);
void vTaskKeyboard(void *pvParameters);
void vTaskLogger(void *pvParameters);
float calculateLuxFromADC(int D, const CalibrationPoint* data);
void initializeRTC();
void setDateTimeFromKeyboard();
void saveToEEPROM(const LogEntry& entry);
void printCalibrationTable();
float calculateError(float measured, float reference);

// ==================== SETUP ====================
void setup() {
    Serial.begin(9600);
    
    // Инициализация дисплея
    lcd.init();
    lcd.backlight();
    lcd.print("Initializing...");
    
    // Инициализация RTC
    initializeRTC();
    
    // Создание очередей
    xLuxQueue = xQueueCreate(10, sizeof(float));
    xLogQueue = xQueueCreate(5, sizeof(LogEntry));
    
    if (xLuxQueue != NULL && xLogQueue != NULL) {
        // Создание задач
        xTaskCreate(vTaskMeasureLuminosity, "Measure", 256, NULL, 4, NULL);
        xTaskCreate(vTaskDisplay, "Display", 256, NULL, 3, NULL);
        xTaskCreate(vTaskRTC, "RTC", 256, NULL, 2, NULL);
        xTaskCreate(vTaskKeyboard, "Keyboard", 256, NULL, 3, NULL);
        xTaskCreate(vTaskLogger, "Logger", 256, NULL, 1, NULL);
        
        vTaskStartScheduler();
    } else {
        lcd.clear();
        lcd.print("Queue Error!");
    }
}

void loop() {}

// ==================== ЗАДАЧИ FreeRTOS ====================
void vTaskMeasureLuminosity(void *pvParameters) {
    float luxValue = 0.0;
    
    for (;;) {
        int adcValue = analogRead(photoPin);
        luxValue = calculateLuxFromADC(adcValue, CalibrationData);
        
        // Отправка в очередь дисплея
        xQueueSend(xLuxQueue, &luxValue, portMAX_DELAY);
        
        // Период 200 мс
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}

void vTaskDisplay(void *pvParameters) {
    float receivedLux;
    static uint8_t displayMode = 0; // 0=lux, 1=ADC, 2=time
    unsigned long lastModeChange = 0;
    
    for (;;) {
        if (xQueueReceive(xLuxQueue, &receivedLux, pdMS_TO_TICKS(1000)) {
            lcd.clear();
            
            switch (displayMode) {
                case 0: // Режим освещенности
                    lcd.setCursor(0, 0);
                    lcd.print("Illuminance:");
                    lcd.setCursor(0, 1);
                    lcd.print(receivedLux, 1);
                    lcd.print(" lx");
                    break;
                    
                case 1: // Режим АЦП
                    lcd.setCursor(0, 0);
                    lcd.print("ADC Value:");
                    lcd.setCursor(0, 1);
                    lcd.print(analogRead(photoPin));
                    lcd.print(" / 1023");
                    break;
                    
                case 2: // Режим времени
                    RtcDateTime now = Rtc.GetDateTime();
                    lcd.setCursor(0, 0);
                    lcd.print("Time:");
                    lcd.setCursor(0, 1);
                    lcd.print(now.Hour()); lcd.print(":");
                    lcd.print(now.Minute()); lcd.print(":");
                    lcd.print(now.Second());
                    break;
            }
            
            // Автопереключение режимов каждые 5 секунд
            if (millis() - lastModeChange > 5000) {
                displayMode = (displayMode + 1) % 3;
                lastModeChange = millis();
            }
        }
    }
}

void vTaskRTC(void *pvParameters) {
    for (;;) {
        RtcDateTime now = Rtc.GetDateTime();
        
        Serial.print("RTC Time: ");
        Serial.print(now.Year()); Serial.print("-");
        Serial.print(now.Month()); Serial.print("-");
        Serial.print(now.Day()); Serial.print(" ");
        Serial.print(now.Hour()); Serial.print(":");
        Serial.print(now.Minute()); Serial.print(":");
        Serial.print(now.Second());
        Serial.println();
        
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void vTaskKeyboard(void *pvParameters) {
    for (;;) {
        char key = keypad.getKey();
        
        if (key) {
            Serial.print("Key pressed: ");
            Serial.println(key);
            
            switch (key) {
                case 'A': // Установка времени
                    setDateTimeFromKeyboard();
                    break;
                    
                case 'B': // Запись в лог
                    LogEntry logEntry;
                    logEntry.lux = calculateLuxFromADC(analogRead(photoPin), CalibrationData);
                    logEntry.timestamp = Rtc.GetDateTime().Unix32Time();
                    strncpy(logEntry.label, "Manual_Log", 20);
                    
                    xQueueSend(xLogQueue, &logEntry, portMAX_DELAY);
                    lcd.clear();
                    lcd.print("Log Saved!");
                    vTaskDelay(pdMS_TO_TICKS(1000));
                    break;
                    
                case 'C': // Тест точности
                    printCalibrationTable();
                    break;
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

void vTaskLogger(void *pvParameters) {
    LogEntry logEntry;
    
    for (;;) {
        if (xQueueReceive(xLogQueue, &logEntry, portMAX_DELAY)) {
            saveToEEPROM(logEntry);
            
            Serial.print("Logged: ");
            Serial.print(logEntry.lux, 1);
            Serial.print(" lx, Label: ");
            Serial.println(logEntry.label);
        }
    }
}

// ==================== ФУНКЦИИ ИНТЕРПОЛЯЦИИ ====================
float calculateLuxFromADC(int D, const CalibrationPoint* data) {
    if (D <= data[0].adc) return data[0].lux;
    if (D >= data[CalibrationSize - 1].adc) return data[CalibrationSize - 1].lux;
    
    for (int i = 0; i < CalibrationSize - 1; ++i) {
        if (D >= data[i].adc && D <= data[i+1].adc) {
            float D1 = data[i].adc;
            float E1 = data[i].lux;
            float D2 = data[i+1].adc;
            float E2 = data[i+1].lux;
            return E1 + (E2 - E1) * ((float)(D - D1) / (D2 - D1));
        }
    }
    return 0.0;
}

// ==================== ФУНКЦИИ RTC ====================
void initializeRTC() {
    Rtc.Begin();
    
    if (!Rtc.IsDateTimeValid()) {
        RtcDateTime compiled = RtcDateTime(__DATE__, __TIME__);
        Rtc.SetDateTime(compiled);
    }
    
    Serial.println("RTC initialized");
}

void setDateTimeFromKeyboard() {
    lcd.clear();
    lcd.print("Set Time Mode");
    // Реализация установки времени через клавиатуру
    // (упрощенно для примера)
}

// ==================== ФУНКЦИИ EEPROM ====================
void saveToEEPROM(const LogEntry& entry) {
    static int currentAddress = 0;
    
    if (currentAddress + sizeof(entry) >= EEPROM.length()) {
        currentAddress = 0; // Перезапись при заполнении
    }
    
    EEPROM.put(currentAddress, entry);
    currentAddress += sizeof(entry);
}

// ==================== ФУНКЦИИ ТЕСТИРОВАНИЯ ====================
void printCalibrationTable() {
    Serial.println("\n=== ТАБЛИЦА ТОЧНОСТИ ===");
    Serial.println("N\tADC\tReference\tMeasured\tError\tRelative%");
    Serial.println("-\t---\t---------\t--------\t-----\t---------");
    
    float maxError = 0;
    float sumRelativeError = 0;
    
    for (int i = 0; i < CalibrationSize; i++) {
        int adc = CalibrationData[i].adc;
        float reference = CalibrationData[i].lux;
        float measured = calculateLuxFromADC(adc, CalibrationData);
        float error = measured - reference;
        float relativeError = (error / reference) * 100;
        
        Serial.print(i + 1);
        Serial.print("\t");
        Serial.print(adc);
        Serial.print("\t");
        Serial.print(reference, 1);
        Serial.print("\t\t");
        Serial.print(measured, 1);
        Serial.print("\t\t");
        Serial.print(error, 1);
        Serial.print("\t");
        Serial.print(relativeError, 1);
        Serial.println("%");
        
        if (fabs(relativeError) > fabs(maxError)) {
            maxError = relativeError;
        }
        sumRelativeError += fabs(relativeError);
    }
    
    float avgError = sumRelativeError / CalibrationSize;
    
    Serial.println("------------------------");
    Serial.print("Макс. погрешность: ");
    Serial.print(maxError, 1);
    Serial.println("%");
    Serial.print("Средняя погрешность: ");
    Serial.print(avgError, 1);
    Serial.println("%");
    
    // Определение класса точности
    if (maxError <= 1.0) {
        Serial.println("Класс точности: 0.5");
    } else if (maxError <= 2.0) {
        Serial.println("Класс точности: 1.0");
    } else if (maxError <= 5.0) {
        Serial.println("Класс точности: 2.5");
    } else {
        Serial.println("Класс точности: 4.0");
    }
}

float calculateError(float measured, float reference) {
    return measured - reference;
}
